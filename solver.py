# -*- coding: utf-8 -*-
"""
Created on Mon May  2 15:15:31 2022

@author: Fran
"""

"""
We'll be saving each cone's coordinates. The target cone's on its own, and the rests' in a set (makes checking for visited states easier, using hashing). A disposition (basically a state) 
is represented as (x,s) where x are the coordinates of the target cone, and s is the set of coordinates of the rest of them (since they are undistinguishable).

What this program does is explore solutions by generating a (|cone| x 4)-ary search tree: each node represents a disposition, and each child represents a disposition that can be reached by a legal move from the parent
distribution (a move is determined by a cone to move and the direction in which it can be moved in). To ensure we do not enter any loops, we will be saving visited dispositions using a map,, 
so we don't visit previously found dispositions: this ensures that the search tree is finite.

Note: As it stands this code does not necessarily generate least-moves solutions. In fact, it ignores many solutions. For example, say we found a certain disposition (x,s) by exploring a path of the search tree starting at the root, and we took 5 moves to reach that 
disposition. Perhaps later in the search tree we wcould encounter said disposition again, but taking less steps. Then the way this code is swt up ignores this disposition because it was visited elsewhere in the tree

One possible thing to be done here is implement something akin to Dijsktra's algorithm on the search tree, by updating every disposition with a parent as we visit them according to the distance from the saved
least distance of the parent to the root. Another would be keeping track of all possible paths, rather than jsut dispositions, and considering only that paths don't loop

I was just interested in finding a solution at the time of writing

As another sidenote I could probably have the program print which cone moves where each time so following solutions is easier
"""

#I wanted to try how partial evaluation works in python
import functools as fun

from enum import Enum

import math

#We are working in a 5x5 grid, and this is the starting configuration of our puzzle. Change these to solve for any other puzzle
starting_disp = ((4,4), frozenset ([(0,4), (0,2), (0,0), (2,0), (4,0)])) #forgot why I used frozenset, IIRC it's because it allows for its value to be hashed

#keep a stack of a path of dispositions that go from the starting one to the last
disp_stack = []

#set of all previously visited positions: we use this to avoid looping infinitely through the same dispositions
visited_disps = set([])

#Set of all solutions generated by this program
solutions = set([])



class Directions(Enum):
    LEFT = 1
    RIGHT = 2
    UP = 3
    DOWN = 4

#these functions return tuples with a boolean indicating whether a is to the specified direction of b, and the distance between them
#Coordinates have their origin at the top left corner. I don't know why I set the first coordinate to the vertical axis and the second to the horizontal one.

class CheckDirections(Enum):
    CHECKLEFT = lambda a,b : ( ((a[0] == b[0]) and (a[1] < b[1])), b[1] - a[1])
    CHECKRIGHT = lambda a,b : (((a[0] == b[0]) and (a[1] > b[1])), a[1] - b[1])
    CHECKUP = lambda a,b : (((a[0] < b[0]) and (a[1] == b[1])), b[0] - a[0])
    CHECKDOWN = lambda a,b : (((a[0] > b[0]) and (a[1] == b[1])), a[0] - b[0])


#apparently python does not have switch expressions so I just map directions to their corresponding functions   
dir_to_check = {Directions.LEFT : CheckDirections. CHECKLEFT, Directions.RIGHT : CheckDirections. CHECKRIGHT, 
                Directions.UP : CheckDirections. CHECKUP, Directions.DOWN : CheckDirections. CHECKDOWN}


#we look for the first cone from b in the given direction (because we can only move in that direction until we collide with that first cone). We return a boolean value indicating whether another
# cone exists in said direction, and the distance to it (is the first element in the tuple is false this second argument has no significance).


def first_cone_direction(direction : Directions, b, disp):
    dist = math.inf                                            #is this value is never updated, it remains infinite
    checked = dir_to_check[direction](disp[0], b)              #first we check whether the target cone is in a certain direction from cone b. Using the map instead of a switch ended up looking much cleaner
    if checked[0]:                                             #if it is, we declare the distance to the target cone as the currently shortest distance to a cone in that direction
        dist = checked[1]                                      
    for c in disp[1]:                                          #we now see if any of the other, undistinguishable cones are in said direction too. For each cone that is, if the distance to it is shorter than the
        checked = dir_to_check[direction](c, b)                #current shortest distance to another cone we update this distance
        if (checked[0]) and (checked[1] < dist):
            dist = checked[1]
    return (dist != math.inf and dist > 1, dist)               #If the distance to the that first cone is 1 we also return False, since we can't move in that direction anyway




#partial evaluation of the function above in each direction. We use these to iterate through checking in each direction
first_cone_left = fun.partial(first_cone_direction, Directions.LEFT)
first_cone_right = fun.partial(first_cone_direction, Directions.RIGHT)
first_cone_up = fun.partial(first_cone_direction, Directions.UP)
first_cone_down = fun.partial(first_cone_direction, Directions.DOWN)


#I liked mapping functions and avoiding many lines of switch statements with basically the same parameters and changing the function, I'm a fan
dir_to_find_cone = {Directions.LEFT :first_cone_left, Directions.RIGHT : first_cone_right, 
                Directions.UP : first_cone_up, Directions.DOWN : first_cone_down}


#cones are tuples of their positions. These functions return the result of moving each cone a certain distance in each direction. 
#Since I liked maps so much I should've mapped directions to tuples but this is compact enough I guess
def move_left(c, dist):
    return (c[0], c[1] - dist)

def move_right(c, dist):
    return (c[0], c[1] + dist)

def move_up(c, dist):
    return (c[0] - dist, c[1])

def move_down(c, dist):
    return (c[0] + dist, c[1])

#Once again, directions get mapped to moving functions

dir_to_move = {Directions.LEFT : move_left, Directions.RIGHT : move_right, 
                Directions.UP : move_up, Directions.DOWN : move_down}


#returns true if the target cone is in the middle. I should probably allow for the target position to be decided on arbitrarily by calling an input at the start so this programs allows for more games than just 5x5, 
#target-in-the-center puzzles
def solved(disp):
    return (2,2) == disp[0]

#convert a disposition into a list
def disp_to_list(disp):
    retVal = [disp[0]]
    for c in disp[1]:
        retVal += [c]
    return retVal

#make the stack containing a path of dispositions into the same but with each disposition as a list
def stack_to_list(stack):
    retVal = []
    for disp in stack:
        retVal += [tuple(disp_to_list(disp))]
    return retVal


#the thing that does the job
def solve(disp):
    disp_stack.append(disp)                                                                 #we add the current disposition to the stack holding a path of dispositions
    visited_disps.add(disp)                                                                 #we have visited this disposition, so we ignore branches that want to visit it again (remember visited_disps is a set)
    if(solved(disp)):
        solutions.add(tuple(stack_to_list(disp_stack)))                                     #if this disposition has the target cone in its center, then the whole stack represents a valid path to a solution
    for cone in [disp[0]] + list(disp[1]):                                                  #for every cone on the board...
        for direc in Directions:                                                            #for every direction the chosen cone can move...
            (can_move, dist) = dir_to_find_cone[direc](cone, disp)                          #we check if this cone can move in said direction
            if can_move:
                new_cone = dir_to_move[direc](cone, dist - 1)                               #coordinates of where this cone ends up after moving it in a valid way in that direction
                if cone == disp[0]:                                                         #this code is kind of ugly, we basically generate the new disposition depending on whether the cone we're checking is the target or not
                    new_disp = (new_cone, disp[1])
                else:
                    new_disp = (disp[0], disp[1].difference({cone}).union({new_cone}))
                if new_disp not in visited_disps:                                           #once we moved the cone, we check whether this disposition has already been visited. If it hasn't, we do a DFS on the search tree
                    solve(new_disp)
    disp_stack.pop()                                                                        #once we have explored all paths from this disposition to unvisited dispositions, we pop it from the path stack


#Like I mentioned at the start, this function is a bit flawed because there is a chance we're not generating the least moves solutions. It does get the shortest one from the ones we generated
def shortest_solution(solution_set):
    retVal = solution_set.pop()
    for solution in solution_set:
        if len(solution) < len(retVal):
            retVal = solution
    return retVal

#prints a disposition to the screen. I could probably also write some code for writing them to a file here. 
#Once again, this only works for 5x5 games, but it's easy to pass the game size as a parameter
def print_disposition(disp):
    for i in range(0,5):
        aux = ""
        for j in range(0,5):
            if (i,j) == disp[0]:
                aux += "X"
            elif (i,j) in disp[1:]:
                aux += "C"
            else: 
                aux += "0"
            aux += " "
        print(aux)


#prints dispositions in a path from the start to the solved disposition in order
def print_solution(solution):
    for disp in solution:
        print_disposition(disp)
        print()

 ###############################################################-------------CODE RUNS HERE-----------------###########################################       
#Generate some solutions, if any exist 
solve(starting_disp)

#here I wanted to get the shortest one found by this program
shortest = shortest_solution(solutions)   

#just print it to the screen
print_solution(shortest)

